<?php

namespace Testify;

use PHPUnit\Framework\TestCase as PhpUnitTestCase;
use RuntimeException;
use ReflectionClass;

/**
 * SpecBridge turns php-testify specs into real PHPUnit TestCase classes.
 *
 * After calling materializeSpecClasses():
 * - For every describe() block, we have a generated class like:
 *   Testify\Generated\Math_basics_0_TestifySpec extends PHPUnit\Framework\TestCase
 *
 * - For every it() inside that describe(), we generate a method:
 *   public function test_adds_numbers_correctly() { ... }
 *
 * - The method calls the original closure you wrote in it().
 *
 * This means PHPUnit can discover/run them like any other PHPUnit test.
 */
final class SpecBridge
{
    /**
     * Generate PHPUnit-compatible classes for all specs.
     *
     * @return array<int, class-string>  List of FQCNs that were created.
     */
    public function materializeSpecClasses(): array
    {
        $suites = TestSuite::getInstance()->all();
        $createdClasses = [];

        foreach ($suites as $suiteIndex => $suite) {
            $fqcn = $this->makeClassName($suite['name'], $suiteIndex);

            $code = $this->generatePhpUnitClassCode($fqcn, $suite['tests']);
            $ok   = eval($code);
            if ($ok === false) {
                throw new RuntimeException(
                    "Failed to eval generated test class for suite '{$suite['name']}'"
                );
            }

            // Inject the closures into the generated class static property.
            $closures = [];
            foreach ($suite['tests'] as $t) {
                $closures[] = $t['fn']; // original callable from it()
            }

            $refClass = new ReflectionClass($fqcn);
            $prop     = $refClass->getProperty('__specClosures');
            $prop->setAccessible(true);
            $prop->setValue(null, $closures);

            $createdClasses[] = $fqcn;
        }

        return $createdClasses;
    }

    /**
     * Build a deterministic FQCN for a describe() block:
     * e.g. "Testify\Generated\Math_basics_0_TestifySpec"
     */
    private function makeClassName(string $suiteName, int $index): string
    {
        $base = preg_replace('/[^A-Za-z0-9_]+/', '_', $suiteName);
        if ($base === '' || $base === null) {
            $base = 'Suite';
        }

        if (!preg_match('/^[A-Za-z_]/', $base)) {
            $base = 'T_' . $base;
        }

        return 'Testify\\Generated\\' . $base . '_' . $index . '_TestifySpec';
    }

    /**
     * Create the PHP class code (string) for the proxy PHPUnit test class.
     *
     * @param string $fqcn
     * @param array<int, array{name:string, fn:callable}> $tests
     */
    private function generatePhpUnitClassCode(string $fqcn, array $tests): string
    {
        $lastSep   = strrpos($fqcn, '\\');
        $ns        = substr($fqcn, 0, $lastSep);
        $shortName = substr($fqcn, $lastSep + 1);

        $methodsCode = [];
        foreach ($tests as $i => $test) {
            $methodName = $this->makeMethodName($test['name'], $i);
            $methodsCode[] = $this->generateMethodCode($methodName, $i);
        }

        // We'll fill $__specClosures after eval() using reflection.
        $closuresArrayInit = $this->generatePlaceholders(count($tests));

        $methodsJoined = implode("\n", $methodsCode);

        $code = <<<PHP
        namespace {$ns};

        use PHPUnit\\Framework\\TestCase as PhpUnitTestCase;
        use Testify\\TestFailureException;

        /**
         * Auto-generated by php-testify SpecBridge.
         * DO NOT EDIT. This class maps describe()/it() specs to PHPUnit tests.
         */
        final class {$shortName} extends PhpUnitTestCase
        {
            /**
             * @var array<int, callable>
             */
            private static array \$__specClosures = {$closuresArrayInit};

            /**
             * Fetch the test closure by index.
             *
             * @throws \\RuntimeException if missing
             */
            public static function getSpecClosure(int \$index): callable
            {
                if (!array_key_exists(\$index, self::\$__specClosures)) {
                    throw new \\RuntimeException("Spec closure not found at index {\$index}");
                }
                return self::\$__specClosures[\$index];
            }

        {$methodsJoined}
        }

        PHP;

        return $code;
    }

    /**
     * Turn "adds numbers correctly" into "test_adds_numbers_correctly".
     */
    private function makeMethodName(string $testName, int $i): string
    {
        $base = preg_replace('/[^A-Za-z0-9_]+/', '_', strtolower($testName));
        if ($base === '' || $base === null) {
            $base = 'case_' . $i;
        }
        if (!preg_match('/^[A-Za-z_]/', $base)) {
            $base = 't_' . $base;
        }
        return 'test_' . $base;
    }

    /**
     * Emit the actual PHPUnit test method body.
     *
     * Each method pulls the closure by index and executes it.
     */
    private function generateMethodCode(string $methodName, int $idx): string
    {
        return <<<PHP

            /**
             * @return void
             */
            public function {$methodName}(): void
            {
                \$fn = self::getSpecClosure({$idx});
                // If the closure throws TestFailureException,
                // PHPUnit will record this as a failed assertion.
                \$fn();
            }

        PHP;
    }

    /**
     * We cannot embed closures directly in code,
     * so we initialize with nulls and patch after eval().
     */
    private function generatePlaceholders(int $howMany): string
    {
        if ($howMany <= 0) {
            return '[]';
        }
        return '[' . implode(', ', array_fill(0, $howMany, 'null')) . ']';
    }
}
